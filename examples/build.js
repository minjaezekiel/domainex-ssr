"use strict";

const fs = require("fs");
const path = require("path");

// React JSX transpile
const babel = require("@babel/core");

// Vue SFC compile
const {
  parse,
  compileTemplate,
  compileScript,
} = require("@vue/compiler-sfc");

const ROOT = __dirname;
const COMPONENTS_DIR = path.join(ROOT, "components");
const DIST_DIR = path.join(ROOT, "dist");

function cleanDist() {
  if (fs.existsSync(DIST_DIR)) {
    fs.rmSync(DIST_DIR, { recursive: true, force: true });
  }
  fs.mkdirSync(DIST_DIR, { recursive: true });
}

function readFiles(dir) {
  if (!fs.existsSync(dir)) {
    throw new Error(`Missing folder: ${dir}`);
  }
  return fs.readdirSync(dir);
}

function writeDist(name, code) {
  const outPath = path.join(DIST_DIR, `${name}.js`);
  fs.writeFileSync(outPath, code, "utf8");
  console.log(`✅ Built -> dist/${name}.js`);
}

function buildReactJSX(filePath) {
  const result = babel.transformFileSync(filePath, {
    presets: [
      ["@babel/preset-env", { targets: { node: "current" } }],
      ["@babel/preset-react", { runtime: "automatic" }]
    ],
    sourceMaps: false,
    babelrc: false,
    configFile: false,
  });

  return result.code;
}

function buildVanillaJS(filePath) {
  return fs.readFileSync(filePath, "utf8");
}

function buildVueSFC(filePath, fileName) {
  const source = fs.readFileSync(filePath, "utf8");

  const { descriptor, errors } = parse(source, { filename: fileName });

  if (errors && errors.length) {
    throw new Error(
      `Vue parse errors:\n${errors.map((e) => String(e)).join("\n")}`
    );
  }

  if (!descriptor.template) {
    throw new Error(`Vue file "${fileName}" has no <template> block.`);
  }

  // Compile <script> / <script setup>
  const compiledScript = compileScript(descriptor, {
    id: `domainex-${fileName}`,
  });

  // Compile template to render() WITHOUT ESM imports
  const templateResult = compileTemplate({
    source: descriptor.template.content,
    filename: fileName,
    id: `domainex-${fileName}`,

    // IMPORTANT: prevent ESM imports like: import { ... } from "vue"
    compilerOptions: {
      mode: "function"
    }
  });

  if (templateResult.errors && templateResult.errors.length) {
    throw new Error(
      `Vue template compile errors:\n${templateResult.errors
        .map((e) => String(e))
        .join("\n")}`
    );
  }

  let scriptCode = compiledScript.content;

  // convert export default -> const __default__ =
  scriptCode = scriptCode.replace(/export default /, "const __default__ = ");

  // remove other exports
  scriptCode = scriptCode.replace(/export \{[^}]+\};?/g, "");

  const finalCode = `
"use strict";

/**
 * Auto-generated by DomainEx build.js
 * Source: ${fileName}
 */

const Vue = require("vue");

${scriptCode}

// Template render function
${templateResult.code}

// Attach render
__default__.render = render;

// Export as CommonJS
module.exports = __default__;
`.trim();

  return finalCode;
}


function main() {
  console.log("Building components...");

  cleanDist();

  const files = readFiles(COMPONENTS_DIR);

  for (const file of files) {
    const filePath = path.join(COMPONENTS_DIR, file);
    const ext = path.extname(file);
    const name = path.basename(file, ext);

    try {
      if (ext === ".jsx") {
        console.log(`• React: ${file}`);
        const code = buildReactJSX(filePath);
        writeDist(name, code);
      } else if (ext === ".vue") {
        console.log(`• Vue: ${file}`);
        const code = buildVueSFC(filePath, file);
        writeDist(name, code);
      } else if (ext === ".js") {
        console.log(`• Vanilla: ${file}`);
        const code = buildVanillaJS(filePath);
        writeDist(name, code);
      } else {
        console.warn(`Skipping unsupported file: ${file}`);
      }
    } catch (err) {
      console.error(`❌ Failed building ${file}`);
      console.error(err);
    }
  }

  console.log("\nBuild completed.");
}

main();
